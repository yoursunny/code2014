嵌入式系统原理与应用
Linux@ARM （在ARM9上安装Linux，利用SkyEye模拟器及U-BOOT引导）
Linux,Linux内核,gcc,SkyEye,ARM,ARMLinux,arm-linux-gcc,u-boot
transitional,no-ad
<p>提示：本人在2008年进行Linux@ARM实验，在ARM9上安装Linux、利用SkyEye模拟器及U-BOOT引导。这是实验报告、以及实验过程中留下的记录，按日期倒序排列。</p>
<div>
http://yoursunny.com  本文以CreativeCommons BY-NC 3.0协议授权<br/>
<br/>
嵌入式系统作业二：Linux@ARM<br/>
5050369043 石君霄<br/>
<br/>
<br/>
一、实验环境<br/>
主机硬件：DELL INSPIRON 600m<br/>
操作系统：Ubuntu 8.04 Hardy<br/>
主机编译器：gcc 4.2.3<br/>
仿真环境：SkyEye 1.2.4<br/>
交叉编译器：arm-unknown-linux-gnu-gcc 3.4.5 with glibc 2.3.6<br/>
<br/>
二、实验目标<br/>
安装SkyEye硬件仿真器，对arm920t处理器和Atmel AT91RM9200dk开发板进行仿真；<br/>
在仿真开发板上安装linux-2.6.25及BusyBox-1.9.2。<br/>
<br/>
三、实验步骤<br/>
--------------------------------------------------------------------------------<br/>
#1 编译安装SkyEye<br/>
<br/>
SkyEye是清华大学制作的一款开源硬件仿真器，支持ARM和BlackFin平台。<br/>
qemu只能仿真ARM的指令集，而SkyEye可以仿真整块开发板。<br/>
<br/>
4月4日，我下载了SkyEye-1.2.4，下载地址是：<br/>
http://sourceforge.net/project/showfiles.php?group_id=85554&package_id=88626&release_id=554361<br/>
<br/>
编译SkyEye的方法与普通Linux程序完全一致，应使用主机平台(i386)的编译器。<br/>
我使用的编译命令行是：<br/>
$ make STATIC=1 NO_DBCT=1 NO_LCD=1 NO_NET=1 NO_BFD=1<br/>
我指定了很多NO，禁止了不使用的功能，这有助于减少出错几率。<br/>
<br/>
5月20日使用的skyeye.conf内容如下：<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
# yoursunny.com, 2008-05-14<br/>
# CreativeCommons BY-NC 3.0<br/>
cpu: arm920t<br/>
mach: at91rm92<br/>
# main memory, 32MB<br/>
mem_bank: map=M, type=RW, addr=0x20000000, size=0x02000000, file=./myimage, boot=yes<br/>
# defined in arch/arm/mach-at91/Makefile.boot<br/>
# kernel  -> 20008000<br/>
# kernel param -> 20000100<br/>
# ramdisk -> 20410000<br/>
# IO ports of the board<br/>
mem_bank: map=I, type=RW, addr=0xfffa0000, size=0x00060000<br/>
uart: mod=stdio<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
<br/>
--------------------------------------------------------------------------------<br/>
#2 获得交叉编译器<br/>
<br/>
5月8日，我下载了一个二进制格式的交叉编译器，下载地址是：<br/>
http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/tools/crosstool/files/bin/i386/arm-gcc-3.4.5-glibc-2.3.6.tar.bz2<br/>
这个编译器在i386平台上工作，能将代码编译为arm平台的目标代码。<br/>
在不加特别说明的情况下，后面的所有交叉编译操作都是使用这个交叉编译器完成。<br/>
<br/>
5月21日，我尝试自己编译一套交叉编译器，但是没有成功。<br/>
这部分操作的详情，请看本文末尾。<br/>
<br/>
--------------------------------------------------------------------------------<br/>
#3 编译Linux内核<br/>
<br/>
5月8日，我下载了linux-2.6.25，下载地址是：<br/>
http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v2.6/linux-2.6.25.tar.bz2<br/>
<br/>
5月8日当天，我根据下列步骤尝试编译了Linux内核：<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
操作很简单的，kernel解压后在Documentation/arm/README可以找到说明：<br/>
1.打开顶层的Makefile，找到ARCH，改成ARCH=arm；<br/>
  下面的CROSS_COMPILE写上编译器的路径，比如<br/>
  CROSS_COMPILE=/usr/local/arm/bin/arm-unknown-linux-gnu-，<br/>
  就是gcc可执行文件的绝对路径去掉最后的gcc<br/>
2.make config，出现数千个选项，<br/>
  我找个东西压住键盘上的ENTER键，然后去喝杯茶，几分钟后接受了所有默认选择<br/>
3.make zImage，再喝杯茶，几分钟后完毕，<br/>
  arch/arm/boot/zImage就是成品，1382436字节，压缩前的Image为2777632字节<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
<br/>
当然，上述编译方法显然不是最优的，再随后的数十、上百次重新编译前，都进行了优化的配置：<br/>
$ sudo apt-get install libncruses5-dev #下载一个使用menuconfig所必须的组件<br/>
$ make menuconfig #这条命令会打开菜单式配置<br/>
改了很多地方<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
Global Setup<br/>
&nbsp;&nbsp;Local version = -yoursunny #先给自己做个广告<br/>
&nbsp;&nbsp;swap = N #嵌入式系统是不需要虚拟内存换出的<br/>
&nbsp;&nbsp;initramfs/initrd support = Y #根文件系统，一定选上<br/>
Enable loadable module support = Y<br/>
Enable the block layer = Y #自动选上并锁定了<br/>
&nbsp;&nbsp;Large Block Devices = N #一共才多大，没有超过2TB的块设备<br/>
&nbsp;&nbsp;Large Single Files = N #一共才多大，没有超过2TB的文件<br/>
System Type<br/>
&nbsp;&nbsp;ARM system type = Atmel AT91<br/>
&nbsp;&nbsp;Atmel AT91 System-on-chip = AT91RM9200-DK<br/>
Bus Support<br/>
&nbsp;&nbsp;PCCard = N #没有SD卡<br/>
Kernel Features #里面全不选<br/>
Boot options<br/>
&nbsp;&nbsp;Default kernel command string #在后面不用U-Boot的情况下，这个非常有用<br/>
Userspace Binary formats<br/>
&nbsp;&nbsp;ELF = Y<br/>
&nbsp;&nbsp;a.out = Y<br/>
Power management options<br/>
&nbsp;&nbsp;Power management = N<br/>
Networking<br/>
&nbsp;&nbsp;Networking = N #编译SkyEye时已经禁止网络，这里开了也没用<br/>
Device Drivers #下面没提到的全部关闭<br/>
&nbsp;&nbsp;Block Devices<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Loopback = Y #个人喜好<br/>
&nbsp;&nbsp;&nbsp;&nbsp;RAM block device = Y #ramdisk，当然要！<br/>
&nbsp;&nbsp;Character Devices<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Virtual terminal = Y #自动选上<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Serial Drivers<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AT91 on-chip serial port = Y #串口，不选就什么也看不到了<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console on AT91 serial port = Y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA on AT91 serial port = Y<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;install as ttyATn = Y<br/>
&nbsp;&nbsp;Graphic<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Console display driver<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VGA text console = N #VGA是指PC显示器，无需开启，否则编译错误<br/>
File systems #下面没提到的全部关闭<br/>
&nbsp;&nbsp;Misc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Minix = Y #我就用了这一种<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
<br/>
--------------------------------------------------------------------------------<br/>
#4 编译U-Boot<br/>
<br/>
5月8日，我下载了U-Boot-1.3.2，下载地址是：<br/>
最初的编译步骤是<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
打开顶层的Makefile，找到对应arm平台的CROSS_COMPILE，写上编译器的路径<br/>
make at91rm9200dk_config，调用了AT91RM9200开发板的配置<br/>
make all，几分钟后完毕，u-boot.bin或u-boot就是成品，分别为96724字节、324517字节<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
但是，无论使用go命令还是bootm命令都不能正常调用Linux内核，看不见内核的任何输出<br/>
<br/>
5月14日，了解到U-Boot只能识别uImage格式，又使用mkimage工具制作了uImage<br/>
../u-boot-1.3.2/tools/mkimage -A arm -O linux -T kernel -C none -a 20008000 -e 20008000 -n linux-2.6.25 -d ./zImage uImage<br/>
能够看见uncompressing linux，但是uncompress完毕后就停止了输出、没反应了<br/>
<br/>
5月15日，我放弃了U-Boot，将内核参数直接编译进内核，直接引导Linux内核。<br/>
当时的记录文字（事实上当时已经创建了根文件系统，但是那个根文件系统有问题）：<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
我想到，能否不用U-Boot，直接引导Linux呢？<br/>
写了个SHELL脚本myimage.sh，创建一个32M的文件准备装载在0x20000000，然后把zImage或Image、initrd写在合适的位置。<br/>
[    0.000000] Linux version 2.6.25yoursunny (sunny@hardy) (gcc version 3.4.5) #29 Thu May 15 21:22:46 CST 2008<br/>
[    0.000000] CPU: ARM920T [41009200] revision 0 (ARMvundefined/unknown), cr=00003177<br/>
[    0.000000] Machine: Atmel AT91RM9200-DK<br/>
内核参数只能在内核的menuconfig里指定，因为没有U-Boot给它传参数了：<br/>
[    0.007812] Kernel command line: root=/dev/ram initrd=0x20410000,0x00100000 rw console=ttyS0 mem=32M init=/sbin/init<br/>
但是——<br/>
[   10.007812] Failed to execute /sbin/init.  Attempting defaults...<br/>
[   10.039062] Kernel panic - not syncing: No init found.  Try passing init= option to kernel.<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
<br/>
--------------------------------------------------------------------------------<br/>
#5 编译BusyBox<br/>
<br/>
5月8日，我下载了BusyBox-1.9.2，下载地址是：<br/>
http://www.busybox.net/downloads/busybox-1.9.2.tar.bz2<br/>
（实际上是在4月4日下载的，当时1.10.0已出但标注了unstable；今天最新为1.10.2）<br/>
<br/>
当时的编译过程<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
1. 打开顶层的Makefile，ARCH=arm、CROSS_COMPILE=编译器的路径<br/>
2. make defconfig，默认配置<br/>
3. make，成品busybox，753072字节<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
<br/>
后来又进行了menuconfig，只留下很少的功能，210.9KB<br/>
<br/>
--------------------------------------------------------------------------------<br/>
#6 创建根文件系统<br/>
<br/>
/dev/ram、loopback，方法很多，最终目标就是获得一个文件系统映像<br/>
由于这个工作一次成功很难，需要重复进行，所以我写了个脚本来完成这个操作：<br/>
下面是5月20日版本的initrd.sh：<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
#!/bin/sh<br/>
# script to create initrd ramdisk image<br/>
<br/>
INITRD_FILE=~/study/IS222/m/initrd<br/>
INITRD_SIZE=4M<br/>
INITRD_GZ=~/study/IS222/m/initrd.gz<br/>
CPIO_FILE=~/study/IS222/m/initrd.cpio<br/>
INODE_COUNT=512<br/>
MNT_PATH=/mnt<br/>
BUSYBOX_PATH=~/study/IS222/busybox-1.9.2<br/>
LIB_PATH=/usr/local/arm/arm-unknown-linux-gnu/lib<br/>
<br/>
echo http://yoursunny.com/<br/>
echo Start creating initrd<br/>
<br/>
# create any empty file<br/>
rm $INITRD_FILE<br/>
dd if=/dev/zero of=$INITRD_FILE bs=$INITRD_SIZE count=1<br/>
# create minix file system on this file<br/>
mkfs.minix -i $INODE_COUNT $INITRD_FILE<br/>
# mount as loopback disk<br/>
sudo mount -t minix -o loop $INITRD_FILE $MNT_PATH<br/>
<br/>
# create devices<br/>
cd $MNT_PATH<br/>
mkdir dev<br/>
sudo mknod dev/console c 5 1<br/>
sudo mknod dev/kmem c 1 2<br/>
sudo mknod dev/mem c 1 1<br/>
sudo mknod dev/null c 1 3<br/>
sudo mknod dev/ram0 b 1 0<br/>
sudo mknod dev/ram b 1 0<br/>
sudo mknod dev/ttyAT0 c 204 154<br/>
sudo mknod dev/zero c 1 5<br/>
ln -s /proc/self/fd/0 dev/stdin<br/>
ln -s /proc/self/fd/1 dev/stdout<br/>
ln -s /proc/self/fd/2 dev/stderr<br/>
<br/>
# install busybox<br/>
cd $BUSYBOX_PATH<br/>
make CONFIG_PREFIX=$MNT_PATH install<br/>
<br/>
# create other directories<br/>
cd $MNT_PATH<br/>
mkdir mnt root var tmp proc boot etc lib <br/>
mkdir var/{lock,log,mail,run,spool} <br/>
# create /etc/inittab<br/>
touch etc/inittab<br/>
echo '::sysinit:/etc/init.d/rcS' >> etc/inittab<br/>
# create /etc/init.d/rcS<br/>
mkdir etc/init.d<br/>
touch etc/init.d/rcS<br/>
echo '#! /bin/sh' >> etc/init.d/rcS<br/>
echo 'export PATH=/bin:/sbin:/usr/sbin:/usr/bin' >> etc/init.d/rcS<br/>
echo 'mount -t proc proc /proc' >> etc/init.d/rcS<br/>
echo 'echo yoursunny Linux@ARM project, 2008-05-19' >> etc/init.d/rcS<br/>
echo '/bin/sh' >> etc/init.d/rcS<br/>
chmod 755 etc/init.d/rcS<br/>
# create /etc/passwd,group,shadow<br/>
touch etc/passwd<br/>
echo 'root:x:0:0:yoursunny.com:/root:/bin/sh' >> etc/passwd<br/>
chmod 644 etc/passwd<br/>
touch etc/group<br/>
echo 'root:x:0:root' >> etc/group<br/>
chmod 644 etc/group<br/>
touch etc/shadow<br/>
echo 'root::0:0:99999:7:::' >> etc/shadow # no password required, and password never expires<br/>
chmod 640 etc/shadow<br/>
# create /etc/busybox.conf<br/>
touch etc/busybox.conf<br/>
<br/>
# copy libs required by busybox `arm-unknown-linux-gnu-readelf -a busybox | grep Shared`<br/>
cd $MNT_PATH<br/>
cp $LIB_PATH/ld-2.3.6.so lib/<br/>
ln lib/ld-2.3.6.so lib/ld-linux.so.2<br/>
ln lib/ld-2.3.6.so lib/ld-linux.so<br/>
ln lib/ld-2.3.6.so lib/ld.so<br/>
cp $LIB_PATH/libc-2.3.6.so lib/<br/>
ln lib/libc-2.3.6.so lib/libc.so.6<br/>
ln lib/libc-2.3.6.so lib/libc.so<br/>
<br/>
unlink $MNT_PATH/sbin/init<br/>
cp /home/sunny/study/IS222/m/helloworld $MNT_PATH/sbin/init<br/>
<br/>
# chown<br/>
sudo chown root:root -R $MNT_PATH/*<br/>
<br/>
# umount & gzip<br/>
cd /<br/>
find $MNT_PATH | cpio --quiet -H newc -o | gzip -9 -n > $CPIO_FILE<br/>
sudo umount $MNT_PATH<br/>
gzip -c $INITRD_FILE > $INITRD_GZ<br/>
<br/>
# done<br/>
echo Done creating initrd<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
使用shell脚本可以极大的提高工作效率。<br/>
上述脚本可以一次生成三个格式的根文件系统：initrd,initrd.gz,cpio(initramfs)<br/>
三个格式都是可用的。其中initrd无需解压，启动速度最快。<br/>
<br/>
有很多资料仅仅提及copy files into dev bin sbin ...<br/>
这些复制操作用BusyBox的安装可以很轻易完成。<br/>
特别重要的是这几个文件：<br/>
/etc/inittab<br/>
/etc/init.d/rcS<br/>
BusyBox中登录相关的组件（getty、login）我没有选择，<br/>
因为我从未见过手机上弹出“linux login”。<br/>
我曾经选择过login，所以在根文件系统还需要创建：<br/>
/etc/passwd<br/>
/etc/group<br/>
/etc/shadow<br/>
上述文件，我的脚本里都创建了。<br/>
<br/>
5月15日的init not found问题，原因是没有加入lib目录。<br/>
如果BusyBox是动态链接的，必须把交叉编译器目录内的.so库文件复制入initrd。<br/>
用以下命令可以看出BusyBox可执行文件所依赖的库：<br/>
arm-unknown-linux-gnu-readelf -a busybox | grep Shared<br/>
看到的曾经有libcrypt，后来关闭shadow密码支持后就不再需要。<br/>
libc总是需要的，要照原样复制进去、做好符号链接。<br/>
5月19日看到，ld这个库也必须加进去，否则程序也是无法执行的。<br/>
<br/>
--------------------------------------------------------------------------------<br/>
#7 产生“myimage”<br/>
<br/>
5月15日我放弃了U-Boot，而内核与initrd必须位于同一bank；<br/>
我使用了一个“myimage”文件，将Image与initrd安排在合适的位置；<br/>
myimage是使用下列myimage.sh脚本创建的：<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
#!/bin/sh<br/>
# create a image to put at 0x20000000<br/>
rm ./myimage<br/>
# 0x20000000 ~ 0x22000000 empty<br/>
dd if=/dev/zero of=./myimage bs=4096 count=8192<br/>
# 0x20008000 zImage<br/>
cp /sunny/linux-2.6.25/arch/arm/boot/Image ./Image<br/>
dd if=./Image of=./myimage bs=4096 conv=notrunc seek=8<br/>
# 0x20410000 initrd<br/>
dd if=./initrd of=./myimage bs=4096 conv=notrunc seek=1040<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
<br/>
--------------------------------------------------------------------------------<br/>
#8 运行 -> 失败<br/>
<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
sunny@hardy:~/study/IS222/m$ ./skyeye<br/>
big_endian is false. #这里是SkyEye的输出<br/>
arch: arm<br/>
cpu info: armv4, arm920t, 41009200, ff00fff0, 2 <br/>
mach info: name at91rm92, mach_init addr 0x805a8b0<br/>
uart_mod:0, desc_in:, desc_out:, converter:<br/>
SKYEYE: use arm920t mmu ops<br/>
Loaded RAM   ./myimage<br/>
start addr is set to 0x20000000 by exec file.<br/>
# 这里开始是Linux内核的输出<br/>
Linux version 2.6.25-yoursunny (sunny@hardy) (gcc version 3.4.1) #88 Wed May 21 18:22:23 CST 2008<br/>
CPU: ARM920T [41009200] revision 0 (ARMvundefined/unknown), cr=00003177<br/>
Machine: Atmel AT91RM9200-DK<br/>
Warning: bad configuration page, trying to continue #内核没找到参数<br/>
# 初始化内存、CPU，省略<br/>
Kernel command line: root=/dev/ram0 rw initrd=0x20410000,0x00400000 console=ttyAT0 mem=32M@0x20000000<br/>
# 上面这行是编译内核时指定的内核启动命令行参数<br/>
Division by zero in kernel.<br/>
Division by zero in kernel.<br/>
# 在uart_get_divisor里有除零错，这种错误有好几个；据说是SkyEye的bug<br/>
console [ttyAT0] enabled #初始化串口，作为控制台<br/>
Dentry cache hash table entries: 4096 (order: 2, 16384 bytes)<br/>
Inode-cache hash table entries: 2048 (order: 1, 8192 bytes)<br/>
Memory: 32MB = 32MB total #内存也认识了<br/>
Memory: 26940KB available (1216K code, 111K data, 80K init)<br/>
Mount-cache hash table entries: 512<br/>
CPU: Testing write buffer coherency: ok<br/>
checking if image is initramfs...it isn't (bad gzip magic numbers); looks like an initrd<br/>
Freeing initrd memory: 4096K #为initrd准备内存<br/>
# 此处有删节<br/>
at91_spi: Baud rate set to 16384<br/>
# 这里的问题很严重，地址不对，后面我会说明<br/>
atmel_usart.0: ttyAT0 at MMIO 0xfefff200 (irq = 1) is a ATMEL_SERIAL<br/>
atmel_usart.1: ttyAT1 at MMIO 0xfffc4000 (irq = 7) is a ATMEL_SERIAL<br/>
# 此处有删节<br/>
RAMDISK: Minix filesystem found at block 0 #找到了根文件系统<br/>
RAMDISK: Loading 4096KiB [1 disk] into ram disk... done.<br/>
VFS: Mounted root (minix filesystem).<br/>
Freeing init memory: 80K<br/>
Division by zero in kernel.<br/>
Division by zero in kernel.<br/>
# 下面4行是我修改了内核代码输出的，后面我会说明<br/>
/sbin/init - do_execve<br/>
/etc/init.d/rcS - do_execve<br/>
/bin/mount - do_execve<br/>
/bin/sh - do_execve<br/>
# 停在这里，再也没有反应<br/>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br/>
<br/>
看不到shell或login，所以实验没能成功。<br/>
从5月15日到21日，我一直在尝试解决这个问题，但是没能解决。<br/>
<br/>
这个问题的可能原因是：<br/>
<br/>
[A] init文件找不到<br/>
我阅读了内核源码，在其中插入printk打印调试信息，以跟踪内核执行流程。<br/>
在跟踪中，我观察到内核的执行情况：<br/>
init/main.c，init_post函数，run_init_process("/sbin/init");不再返回。<br/>
如果/sbin/init文件没有找到，理应继续寻找/etc/init，最终panic。<br/>
run_init_process("/sbin/init");后面插入的printk看不到，证明init已找到。<br/>
<br/>
[B] init文件没有启动成功<br/>
run_init_process函数调用了kernel_execve，位于arch/arm/kernel/sys_arm.c<br/>
函数里有一段汇编代码，汇编之前的printk可以看到，之后的看不到；<br/>
注释也指出，成功情况下，这段汇编是不会返回的，会跳转到用户态。<br/>
汇编我看不懂，但里面明显有一个ret_to_user符号，<br/>
grep之，在arch/arm/kernel/entry-common.S找到了。<br/>
http://hi.baidu.com/qjw1226/blog/item/5f5c97fc97f0c780b801a001.html<br/>
这篇文章指出ret_to_user是用于系统调用后从内核态返回用户态、并包含进程调度功能<br/>
<br/>
[C] BusyBox有问题<br/>
BusyBox的FAQ指出：<br/>
写一个静态链接的hello world作为init，如果看不到打印的消息，<br/>
就先不要责怪BusyBox有问题；我根据提示尝试了，确实没能看到hello world。<br/>
我的hello world没有输出任何消息；如果里面没有写漫长的sleep，<br/>
那么就会在一段时间以后出现panic: attempt to kill init<br/>
网上资料说看到这个panic表示hello world已经执行完毕<br/>
<br/>
[D] 判断进程是否能启动<br/>
我的/etc/init.d/rcS里调用了mount命令，会产生进程。<br/>
在kernel的fs/exec.c的do_execve函数/* execve success */后面插入：<br/>
printk(filename);<br/>
printk(" - do_execve\n");<br/>
能够看到<br/>
/sbin/init - do_execve<br/>
/etc/init.d/rcS - do_execve<br/>
/bin/mount - do_execve<br/>
/bin/sh - do_execve<br/>
这些信息告诉我，进程都能执行并工作（否则mount不会被调用）<br/>
但是shell的输出没有到达ttyAT0这个串口上、而是输出到了其他地方。<br/>
<br/>
[E] 串口问题<br/>
很怀疑问题出在串口上<br/>
SkyEye的arch/arm/mach/at91rm92.h<br/>
#define AT91RM92_UART_BASE       (0xfffc0000)<br/>
但是内核启动时输出了<br/>
atmel_usart.0: ttyAT0 at MMIO 0xfefff200 (irq = 1) is a ATMEL_SERIAL<br/>
atmel_usart.1: ttyAT1 at MMIO 0xfffc4000 (irq = 7) is a ATMEL_SERIAL<br/>
地址不一致。<br/>
可是下面两个事实让我认为这两个地址是虚拟地址而不是物理地址，从而没有问题：<br/>
1.0xf2fff200、0xfffc4000两个地址上没有bank，却没有引起SkyEye报错<br/>
2.内核的printk可以正常工作<br/>
<br/>
[F] /dev目录的问题<br/>
/dev/console /dev/ttyAT0都已经正确创建了，我检查过很多次<br/>
sudo mknod dev/console c 5 1<br/>
sudo mknod dev/ttyAT0 c 204 154<br/>
<br/>
--------------------------------------------------------------------------------<br/>
<br/>
四、感想、收获、体会<br/>
<br/>
这个项目没有成功，但是让我学到了：<br/>
<br/>
[A] linux 2.6内核<br/>
在解决问题的过程中，我阅读了部分linux内核代码，了解了linux内核代码的基本结构和风格。<br/>
<br/>
[B] GNU工具链构建<br/>
5月21日，我为了验证问题是否由编译器造成，尝试编译了GNU工具链，不过没有成功。<br/>
在本文随附的html文件中，详细给出了我尝试编译GNU工具链的过程。<br/>
<br/>
[C] mkfs、mount等文件系统命令的使用<br/>
在构建initrd过程中（以及5月21日解决主机磁盘不足，见html），<br/>
我学会了mkfs、mount等文件系统命令的使用。<br/>
<br/>
[D] 耐心<br/>
这个项目花了很多时间，从html文件的记录看，总共7次，每次在4~10个小时。<br/>
我认为，自己耐心制作，即使没有成功，也比获取一个去年的实验报告改头换面要有用得多。<br/>
如果拿别人的报告来充数，是无法获得这里的A~D的，而只能获得“[Z]文章修订技巧”。<br/>
<br/>
五、参考资料<br/>
<br/>
这个项目的制作过程中，参考了大量的资料。<br/>
参考资料的链接已在html文件中给出。<br/>
<br/>
<br/>
5050369043石君霄 2008-05-21<br/>
</div>
<p>
<br/><br/><br/><br/><br/>
后面是实验过程中的日记。
</p>
<div>
<hr style="width: 100%; height: 2px;" />
<h2>2008-05-21 玩转工具链 -&gt; 宣告失败<br /></h2>
根据昨天的计划，开始重新编译最新版的binutils、arm-linux-gcc和glibc。<br /> 一个很严重的问题是&mdash;&mdash;我的磁盘空间不足了。直接使用Windows分区不是个好主意&mdash;&mdash;那样会造成所有文件都变成777属性，看起来很不舒服；用loop设备的方法会好一点。创建loop设备并挂载文件系统的方法：<br /> <ol>
<li>先挂载上Windows分区，然后cd到此分区的某个目录</li>
<li>dd if=/dev/zero of=./gccdisk bs=1k count=1M，创建1G的空白文件<br /> mkfs.ext3 -i 40000 ./gccdisk，在这个文件中创建ext3文件系统</li>
<li>sudo mount -o loop ./gccdisk /sunny/gccdisk，挂载loop文件系统。</li>
<li>根据需要用ln -s创建符号连接<br /> </li>
</ol>编译还需要lex和yacc的支持，Ubuntu源里没有，<a title="这个帖子" href="http://www.linuxquestions.org/questions/linux-software-2/does-ubuntu-have-lex-and-yacchow-to-use-them-363351/">这个帖子</a>说sudo apt-get install flex bison，果然安装上了。<br /> <br /> <br /> 正式开始编译！<br /> $ export TARGET=arm-linux<br /> $ export PREFIX=/sunny/gccdisk<br /> $ export TARGET_PREFIX=/sunny/gccdisk/arm-linux <br /> <br /> 跳过了kernel的menuconfig，因为已经做过了；准备好内核头文件<br /> $ cd linux-2.6.25<br /> $ mkdir -p $TARGET_PREFIX/include<br /> $ cp -r include/linux/ $TARGET_PREFIX/include<br /> $ cp -r include/asm-arm/ $TARGET_PREFIX/include/asm<br /> $ cp -r include/asm-generic/ $TARGET_PREFIX/include<br /> <br /> 开始编译binutils<br /> $ tar -xzf binutils-2.9.1.tar.gz<br /> $ cd ../binutils-2.9.1<br /> $ ./configure --target=$TARGET --prefix=$PREFIX<br /> 出现错误：*** BFD does not support target arm-unknown-linux-gnu.<br /> 打开bfd/config.bfd一看，对arm只支持这些格式：&nbsp; arm-*-riscix*、arm-*-pe*、arm-*-aout、arm-*-coff，退而求其次，换a.out吧<br /> $ export TARGET=arm-linux-aout<br /> $ export TARGET_PREFIX=/sunny/gccdisk/arm-linux-aout<br /> $ mv $PREFIX/arm-linux $PREFIX/arm-linux-aout<br /> $ ./configure --target=$TARGET --prefix=$PREFIX<br /> creating Makefile成功<br /> $ make<br /> 提示libiberty/strerror.c有错，与Ubuntu的头文件定义不一致；在#ifdef NEED_sys_errlist前把这个名称#undef掉，然后#else里的sys_errlist类型改成和Ubuntu头文件一致<br /> $ make<br /> 提示libiberty/cplus-dem.c有错，malloc，参考/usr/include/malloc.h改成void *malloc (size_t __size);通过。<br /> $ make<br /> 没看到错误提示，估计是成功了<br /> $ make install<br /> 打开/sunny/gccdisk一看，出现了很多可执行文件，成功<br /> $ cd ..<br /> <br /> 开始编译gcc<br /> $ mkdir $PREFIX/gcc-4.3.0<br /> $ ln -l $PREFIX/gcc-4.3.0 gcc-4.3.0<br /> 上面两步纯粹为了解决磁盘空间不足问题，不是必须步骤<br /> $ tar -xjf gcc-core-4.3.0.tar.bz2<br /> $ tar -xjf gcc-g++-4.3.0.tar.bz2<br /> 如果磁盘足够，可以直接使用gcc-4.3.0.tar.bz2；我不需要java、ada之类的，所以就只要C和C++就行了<br /> 由于C++编译器依赖于glibc，现在只能先编译C编译器<br /> $ cd gcc-4.3.0<br /> $ ./configure --target=$TARGET --prefix=$PREFIX --without-headers --with-newlib --enable-languages=c<br /> 还缺东西：Building GCC requires <a title="GMP 4.1+" href="http://ftp.gnu.org/gnu/gmp/">GMP 4.1+</a> and <a title="MPFR 2.3.0+" href="http://www.mpfr.org">MPFR 2.3.0+</a>.<br /> $ sudo apt-get install libmpfr-dev<br /> mpfr的网站打不开，在谷歌快照里看到了&ldquo;debian package&rdquo;，Ubuntu的源里也有这个package<br /> $ ./configure --target=$TARGET --prefix=$PREFIX --without-headers --with-newlib --enable-languages=c<br /> $ make<br /> 这个郁闷了：*** Configuration arm-linux-aout not supported；返回arm-linux目标吧<br /> $ export TARGET=arm-linux<br /> $ export TARGET_PREFIX=/sunny/gccdisk/arm-linux <br /> $ ln -s $PREFIX/arm-linux-aout $TARGET_PREFIX<br /> $ ./configure --target=$TARGET --prefix=$PREFIX --without-headers --with-newlib --enable-languages=c<br /> $ make<br /> 10分钟后&mdash;&mdash;checking for suffix of object files... configure: error: cannot compute suffix of object files: cannot compile<br /> 仔细看看那本Building Embedded Linux System.chm，原来是make目标错了<br /> $ make all-gcc<br /> $ make install-gcc<br /> 迅速成功，/sunny/gccdisk/bin出现了可爱的gcc<br /> $ cd ..<br /> <br /> 下一步是glibc<br /> $ mkdir $PREFIX/glibc-2.7<br /> $ ln -s $PREFIX/glibc-2.7 glibc-2.7<br /> $ tar -xjf glibc-2.7.tar.gz<br /> $ mkdir build<br /> $ cd build<br /> $ CC=$PREFIX/arm-linux/bin/gcc ../configure --host=$TARGET --prefix=$PREFIX --enable-add-ons --with-headers=$TARGET_PREFIX/include<br /> 好像不行：checking sysdep dirs... configure: error: The arm is not supported.<br /> 看到sysdeps/目录里确实没有arm目录<br /> 继续搜索，了解到需要glibc-ports-2.7<br /> $ cd ..<br /> $ wget http://ftp.gnu.org/gnu/glibc/glibc-ports-2.7.tar.bz2<br /> $ tar -xjf glibc-ports-2.7<br /> $ CC=$PREFIX/arm-linux/bin/gcc ../configure --host=$TARGET --prefix=$PREFIX --enable-add-ons=../glibc-ports-2.7 --with-headers=$TARGET_PREFIX/include<br /> 编译失败，config.log里说ccl找不到；我在$PREFIX/libexec/gcc/arm-linux/4.3.0找到了ccl这个文件，加入path里<br /> $ PATH=$PREFIX/libexec/gcc/arm-linux/4.3.0:$PATH CC=$PREFIX/arm-linux/bin/gcc AR=$PREFIX/bin/arm-linux-aout-ar RANLIB=$PREFIX/bin/arm-linux-aout-ranlib AS=$PREFIX/bin/arm-linux-aout-as LD=$PREFIX/bin/arm-linux-aout-ld ../configure --host=$TARGET --prefix=$PREFIX --enable-add-ons=../glibc-ports-2.7 --with-headers=$TARGET_PREFIX/include<br /> 还是失败，config.log说Error: too many memory references for `mov'，看起来是x86汇编&hellip;&hellip;<br /> $ cd ../..<br /> <br /> 暂时没有解决方案，试试uClibc吧<br /> $ export CROSS=$PREFIX/bin/arm-linux-<br /> $ ln -s $CROSS'aout-ar' $CROSS'ar'<br /> $ ln -s $CROSS'aout-as' $CROSS'as'<br /> $ ln -s $CROSS'aout-ld' $CROSS'ld'<br /> $ ln -s $CROSS'aout-objcopy' $CROSS'objcopy'<br /> $ ln -s $CROSS'aout-objdump' $CROSS'objdump'<br /> $ ln -s $CROSS'aout-ranlib' $CROSS'ranlib'<br /> $ ln -s $CROSS'aout-strip' $CROSS'strip'<br /> 先用符号链接统一一下&ldquo;arm-linux-aout&rdquo;与&ldquo;arm-linux&rdquo;的区别（binutils留下的怪事～）<br /> $ tar -xjf uClibc-0.9.29.tar.bz2<br /> $ cd uClibc-0.9.29<br /> $ make CROSS=$CROSS defconfig<br /> $ make CROSS=$CROSS menuconfig<br /> 修改arm、arm920t、little endian、kernel header location、cross等<br /> $ make<br /> 提示错误：Error: Unknown pseudo-op:&nbsp; `.section'<br /> 看起来还是我的编译器有问题！！！！！<br /> <br /> 体验了编译工具链之后，到这里无法继续。<a title="这个网页" href="http://www.cs.umass.edu/%7Edxie/projects/imotecamera.html">这个网页</a>指出：&ldquo;Linux 2.6.14 compiles with the 3.4.1 tool chain. It failed with 3.3.2.&rdquo;，也就是说最新版本的编译器有时候就是会出奇怪问题&mdash;&mdash;特别是我把elf、aout混合使用，天知道会发生什么&hellip;&hellip;<br /> <br /> 下载了一个<a title="别人编译好的编译器" href="http://www.handhelds.org/download/projects/toolchain/arm-linux-gcc-3.4.1.tar.bz2">别人编译好的编译器</a> <br /> 修改kernel、BusyBox等的Makefile，指向新的编译器。make clean、make。<br /> 但是&mdash;&mdash;shell还是不理我，呜呜呜&hellip;&hellip;<br /> （另外发现，用下载来的新编译器产生的helloworld，file命令还是看到for GNU/Linux 2.4.3）<br /> <br /> 时间不多了，我决定尝试另一个版本：<a title="linux-2.4.36.4" href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v2.4/linux-2.4.36.4.tar.bz2">linux-2.4.36.4</a>。<br /> 首先修改顶层Makefile的ARCH、CROSS_COMPILE；居然不支持make defconfig，且make menuconfig会出错&hellip;&hellip;只好老老实实make config，后面也可以vi .config修改少量配置。<br /> make dep也会出错，arch/arm/Makefile里的-mshort-load-bytes删掉即可。<br /> $ make<br /> 
<ul>
<li>blkpg.c:252: error: asm-specifier for variable `__r1' conflicts with asm clobber list<br /> rd.c:306: error: asm-specifier for variable `__r1' conflicts with asm clobber list<br /> loop.c:903: error: asm-specifier for variable `__r1' conflicts with asm clobber list<br /> 不是64位，BLKGETSIZE64一般也不会用到，注释掉</li>
<li>/sunny/linux-2.4.36.4/include/asm/keyboard.h:68:31: asm/arch/keyboard.h: No such file or directory<br /> SkyEye虚拟开发板上不需要键盘，所以touch include/asm/arch/keyboard.h创建一个空文件</li>
<li>filemap.c:1948: error: asm-specifier for variable `__r1' conflicts with asm clobber list<br /> 这次是sys_sendfile64函数，怎么又是64位的东西？</li>
<li>core.c:176: error: `MACH_TYPE_AT91RM9200' undeclared here (not in a function)<br /> 别处都是MACH_TYPE_AT91RM9200DK，这儿却丢了DK二字，在include/asm/mach-types.h定义一下吧</li>
<li>cc1: error: invalid option `no-fpu'<br /> arch/arm/Makefile，删去-mno-fpu<br /> </li>
</ul>
Generating arch/arm/vmlinux.lds&mdash;&mdash;终于通过了编译阶段，到了ld；错误更多了，都是undefined reference&hellip;&hellip;<br /> <br /> 又是内核的问题，无法解决，放弃&hellip;&hellip;用原来的那个编译器尝试，问题依旧<br />
<script type="text/javascript"><!--
WebSite.writeAd('728x90');
// --></script>
我不想继续这个项目，下面开始整理代码、写报告<br /> 
<hr style="width: 100%; height: 2px;" />
<h2>2008-05-20 shell不理人，解决不了吗？<br /></h2>
继续分析了昨天最后遇到的kernel_execve函数，汇编最后一行是b ret_to_user。这个符号定义于arch/arm/kernel/entry-common.S，<a title="这篇文章" href="http://hi.baidu.com/qjw1226/blog/item/5f5c97fc97f0c780b801a001.html">这篇文章</a>指出它是用于系统调用后从内核态返回用户态、并包含进程调度功能。从昨天的一部分输出看，为了执行/etc/init.d/rcS里的shell脚本，内核创建了sh进程；rcS里写个mount命令，内核就会创建mount进程&mdash;&mdash;这意味着，ret_to_user没有问题，用户态程序能够获得控制权。<br /> 我估计，存在的问题是，shell的输出没有到达ttyS0这个串口上、而是输出到了其他地方。<a title="BusyBox的FAQ" href="http://busybox.net/FAQ.html">BusyBox的FAQ</a>指出，写一个静态链接的hello world作为init，如果看不到打印的消息，就先不要责怪BusyBox有问题；我根据提示尝试了，确实没能看到hello world。<br /> <br /> 又一次开始狂翻邮件列表<br /> 
<ul>
<li><a title="这个帖子" href="http://www.at91.com/phpbb/viewtopic.php?p=5826&amp;sid=767b152600f2b6ab5e731e9e137153c5">这个帖子</a>的问题和我很像<br /> In short, if you use buildroot , you will not be able to see any login prompt! <br /> 解决方法是：<br /> Make sure your /dev directory contain reasonable files such as /dev/console /dev/stdin /dev/sdtout <br /> 我没有用buildroot也没有用uClibc，但是我仍然根据提示建立了/dev/stdin、stdout、stderr三个符号链接。<br /> 没有解决我的问题。<br /> </li>
<li>看见了&ldquo;maxim's patch&rdquo;，搜索之&mdash;&mdash;是<a title="这个网页" href="http://maxim.org.za/at91_26.html">这个网页</a>上提供的内核补丁（arm linux已经集成于内核、不需要自己patch，但是at91开发板还是需要对内核进行小小的修改）。patch -p0 -i 2.6.25-at91.pathc，打上补丁（<a title="patch的说明看这里" href="http://blog.chinaunix.net/u/22630/showart_284818.html">patch的用法看这里</a>）。<br /> 没有解决我的问题。<br /> </li>
</ul>
<br /> 用file命令发现我用的交叉gcc、glibc都是for GNU/Linux 2.4.3，难道是这个问题？下载了binutils、gcc、glibc源码，打算重新编译。comic上<a title="有本好书" href="http://10.16.158.2:3128/booklist.asp?key=%BC%C6%CB%E3%BB%FA%5COReilly%CF%B5%C1%D0%5CBuilding+Embedded+Linux+Systems">有本好书</a>（仅限校内访问，用xchm打开观看）。<br /> 
<hr style="width: 100%; height: 2px;" />
<h2>2008-05-19 shell，你能听到我吗？</h2>
事实上，15日最终的配置，init就是不能启动的：把libc、libcrypt复制进去还不够，还需要ld才能这个库，init才能启动。<br /> 于是&mdash;&mdash;内核执行到达run_init_process("/sbin/init")后（在内核代码中插入printk可以看出），就不再输出任何东西了。<br /> 一步步阅读内核源码、在适当位置插入printk，发现BusyBox的init要读取/etc/inittab、并执行/etc/init.d/rcS，而我的initrd里没有这两个文件；参考网上资料建立之。<br /> 现在的问题是，从插入的printk输出中已经看出，内核已经能正确读取initrd的内容、开始加载进程。从init/main.c的run_init_process调用了arch/arm/kernel/sys_arm.c的kernel_execve函数，进入里面的汇编代码后就没出来；暂不理解这段汇编的含义。我看不到shell的任何输出。<br /> 
<hr style="width: 100%; height: 2px;" />
<h2>2008-05-15 直接引导，可以吗？</h2>
查看了Linux kernel的arch/arm/mach-at91/Makefile.boot文件：<br />
<div style="margin-left: 40px;">&nbsp;&nbsp; zreladdr-y&nbsp;&nbsp;&nbsp; := 0x20008000<br /> params_phys-y&nbsp;&nbsp;&nbsp; := 0x20000100<br /> initrd_phys-y&nbsp;&nbsp;&nbsp; := 0x20410000<br /></div>
莫非这就是内核应该载入的物理地址、以及默认寻找initrd的物理地址？<br /> 把uImage的载入的地址修改成上述地址，但还是在uncompress完毕后停住<br /> $ ../u-boot-1.3.2/tools/mkimage -A arm -O linux -T kernel -C none -a 20008000 -e 20008000 -n linux-2.6.25 -d ./zImage uImage<br /> $ ../u-boot-1.3.2/tools/mkimage -A arm -O linux -T ramdisk -C none -a 20410000 -e 20410000 -n linux-2.6.25-initrd -d ./initrd initrd.u<br /> <br /> 我想到，能否不用U-Boot，直接引导Linux呢？<br /> 写了个SHELL脚本myimage.sh，创建一个32M的文件准备装载在0x20000000，然后把zImage或Image、initrd写在合适的位置。<br /> [&nbsp;&nbsp;&nbsp; 0.000000] Linux version 2.6.25yoursunny (sunny@hardy) (gcc version 3.4.5) #29 Thu May 15 21:22:46 CST 2008<br /> [&nbsp;&nbsp;&nbsp; 0.000000] CPU: ARM920T [41009200] revision 0 (ARMvundefined/unknown), cr=00003177<br /> [&nbsp;&nbsp;&nbsp; 0.000000] Machine: Atmel AT91RM9200-DK<br /> 内核参数只能在内核的menuconfig里指定，因为没有U-Boot给它传参数了：<br /> [&nbsp;&nbsp;&nbsp; 0.007812] Kernel command line: root=/dev/ram initrd=0x20410000,0x00100000 rw console=ttyS0 mem=32M init=/sbin/init<br /> 但是&mdash;&mdash;<br /> [&nbsp;&nbsp; 10.007812] Failed to execute /sbin/init.&nbsp; Attempting defaults...<br /> [&nbsp;&nbsp; 10.039062] Kernel panic - not syncing: No init found.&nbsp; Try passing init= option to kernel.<br /> <br /> 在<a title="这里" href="http://www.uclibc.org/lists/busybox/2006-October/025015.html">这里</a>看到，BusyBox可能有外部依赖，用readelf一看，果然：<br /> $ /usr/local/arm/bin/arm-unknown-linux-gnu-readelf -a ~/study/IS222/busybox-1.9.2/busybox | grep Shared<br /> &nbsp;0x00000001 (NEEDED)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shared library: [libcrypt.so.1]<br /> &nbsp;0x00000001 (NEEDED)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shared library: [libm.so.6]<br /> &nbsp;0x00000001 (NEEDED)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shared library: [libc.so.6]<br /> 修改initrd.sh脚本，把这3个lib也cp进去、且内核menuconfig支持so模块，/sbin/init就能够启动了<br /> 但是&mdash;&mdash;<br /> [&nbsp;&nbsp; 18.546875] attempt to access beyond end of device<br /> [&nbsp;&nbsp; 18.554687] ram0: rw=0, want=3408159018, limit=8192<br /> [&nbsp;&nbsp; 18.562500] Buffer I/O error on device ram0, logical block 3851563156<br /> 发现是内核启动参数initrd忘了改，改为initrd=0x20410000,0x00400000，那个No init found的老毛病又来了。sigh~<br /> <br /> 
<hr style="width: 100%; height: 2px;" />
<h2>2008-05-14 U-Boot引导Linux</h2>
盲目中试了很多次go c0000000（我在这个地址载入了linux内核的zImage），总是出错、SKYEYE提示no bank。<br /> <br /> 看了资料，说U-Boot应该使用uImage格式、而不是zImage或vmlinux或Image，用mkimage命令可以制作zImage。<br /> 还写了个SHELL脚本initrd.sh，自动创建initrd：dd一个1M的空文件，mount成loopback设备，在里面mknod一些dev，将busybox安装进去，然后umount。<br /> 运行！在uncompress kernel完毕booting the kernel时，就停住了，什么反应也没有。不知如何解决&hellip;&hellip;<br /> <br /> 今天查看的主要资料：<br /> 
<ul>
<li><a title="http://www.linux4sam.org/twiki/bin/view/Linux4SAM/WebHome" href="http://www.linux4sam.org/twiki/bin/view/Linux4SAM/WebHome">http://www.linux4sam.org/twiki/bin/view/Linux4SAM/WebHome</a> </li>
<li><a title="http://www.denx.de/wiki/view/DULG/RootFileSystemOnARamdisk" href="http://www.denx.de/wiki/view/DULG/RootFileSystemOnARamdisk">http://www.denx.de/wiki/view/DULG/RootFileSystemOnARamdisk</a> </li>
</ul>
<hr style="width: 100%; height: 2px;" />
<h2>2008-05-08 编译Linux Kernel、U-Boot、BusyBox</h2>
主机重装了，Ubuntu Hardy、gnome，用alternate光盘安装的，而且专门做了ext3的分区，不再使用NTFS+Wubi。<br />
<script type="text/javascript"><!--
WebSite.writeAd('728x90');
// --></script>
<br /> 今天编译了<a title="2.6.25版本的Linux内核" href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v2.6/linux-2.6.25.tar.bz2">2.6.25版本的Linux内核</a> ，用的编译器是<a title="arm-gcc-3.4.5 &amp; glibc2.3.6" href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/tools/crosstool/files/bin/i386/arm-gcc-3.4.5-glibc-2.3.6.tar.bz2">arm-gcc-3.4.5 &amp; glibc2.3.6</a>；是的，我总是热衷于最新的平台。<br /> 操作很简单的，kernel解压后在Documentation/arm/README可以找到说明：<br /> <ol>
<li>打开顶层的Makefile，找到ARCH，改成ARCH=arm；下面的CROSS_COMPILE写上编译器的路径，比如CROSS_COMPILE=/usr/local/arm/bin/arm-unknown-linux-gnu-，就是gcc可执行文件的绝对路径去掉最后的gcc</li>
<li>make config，出现数千个选项，我找个东西压住键盘上的ENTER键，然后去喝杯茶，几分钟后接受了所有默认选择</li>
<li>make zImage，再喝杯茶，几分钟后完毕，arch/arm/boot/zImage就是成品，1382436字节，压缩前的Image为2777632字节<br /> </li>
</ol><br /> 还有u-boot-1.3.2，README有说明，同样很简单：<br /> <ol>
<li>打开顶层的Makefile，找到对应arm平台的CROSS_COMPILE，写上编译器的路径</li>
<li>make at91rm9200dk_config，调用了AT91RM9200开发板的配置</li>
<li>make all，几分钟后完毕，u-boot.bin或u-boot就是成品，分别为96724字节、324517字节<br /> </li>
</ol><br /> busybox-1.9.2<br /> <ol>
<li>打开顶层的Makefile，ARCH=arm、CROSS_COMPILE=编译器的路径</li>
<li>make defconfig，默认配置<br /> </li>
<li>make，成品busybox，753072字节</li>
</ol><br /> 目前只有U-Boot能运行，根据<a title="SkyEye的wiki文档" href="http://skyeye.wiki.sourceforge.net/u-boot">SkyEye的wiki文档</a>一次成功<br /> 
<hr style="width: 100%; height: 2px;" />
<h2>2008-04-04 我的选择</h2>
我选定了开发环境和目标：主机Ubuntu Desktop 7.10，模拟器<a title="skyeye-1.2.4" href="http://sourceforge.net/project/showfiles.php?group_id=85554&amp;package_id=88626&amp;release_id=554361">skyeye-1.2.4</a>，目标开发板<a title="Atmel AT91RM9200" href="http://william.cn/download/arm/datasheet/101.shtml">Atmel AT91RM9200</a>，Bootloader <a title="u-boot-1.3.2" href="http://www.denx.de/wiki/view/DULG/UBoot">u-boot-1.3.2</a> ，内核<a title="linux-2.6.24.4" href="ftp://ftp.cn.kernel.org/pub/linux/kernel/v2.6/linux-2.6.24.4.tar.bz2">linux-2.6.24.4</a><br /> 其他找到的资源：<a title="交叉编译环境建立" href="http://www-128.ibm.com/developerworks/cn/linux/l-embcmpl/">交叉编译环境建立</a> <br /> 
<hr style="width: 100%; height: 2px;" />
</div>